---
title: Who uses Socrata?
tweet_text: When I downloaded all of the @socrata datasets, I also downloaded all of the users.
---

(Introduction here)

## The user data
I'm still using the same 80,000 JSON files that I downloaded last month.
Each of these metadata files describes a Socrata view. Among their many
fields are two fields related to the people who interacted with that view.
These fields are the `owner` and  `tableAuthor` fields. These fields are
both hashes/dictionaries/arrays with user information. For example, here's
mine.

    {
        "id" : "x73b-9d8f",
        "displayName" : "Thomas Levine",
        "emailUnsubscribed" : false,
        "privacyControl" : "login",
        "profileLastModified" : 1371141485,
        "screenName" : "Thomas Levine"
    }

### `owner`
The `owner` field is quite straightforward; it's simply the person who
created the view, be it a dataset, chart, map or whatever.

### `tableAuthor`
The `tableAuthor` field is the person who uploaded the dataset associated
with the view. For datasets, this is the same as the owner, but for charts,
maps and filtered views, it might be different; one person may have uploaded
the data, and another person might have made the chart. "view", "dataset",
"map", "chart", "filtered view" and "table" all have rather special meanings
inside Socrata, so you should read my [post on that](/!/socrata-genealogies)
if the previous sentence didn't make sense.

## Extracting the user data
I already had a system for storing all of the Socrata metadata, so I just needed to write a
[sloppy function](https://github.com/tlevine/socrata-analysis/blob/e3d12254e928f986f1a83ed2099577e289048b94/numbers/run.py#L207)
to query it. This resulted in an SQLite3 database, which I converted to a
[CSV file](https://raw.github.com/tlevine/socrata-analysis/e3d12254e928f986f1a83ed2099577e289048b94/users.csv)
and read into R.

<!--
In case a view was federated, only one copy is counted, so this doesn't
have the duplication issues that some people were concerned about.
-->

Rather than remembering which tables and datasets everyone owned, that function
just remembers how many. Maybe I'll do something with the links later.

## Analysis
The table schema looks like this.

```{r schema}
str(users)
```

### Missing data
Not everyone had all of the fields. For example, hardly anyone has a profile image.

```{r profile.image}
table(is.na(users$profileImageUrlLarge))
```

```{r missingness}
a <- t(as.data.frame(lapply(users, function(variable){ sum(!is.na(variable)) } )))
missingness <- data.frame(
  variable = rownames(a),
  present.value = a[,1]
)
missingness <- missingness[order(missingness$present.value, decreasing = T),]
barplot(
  (missingness$present.value),
  names.arg = missingness$variable,
  border = NA, col = 'grey', axes = F, horiz = T, las = 1,
  xlim = c(0, 12000),
  main = 'How complete is the user profile metadata?',
  xlab = 'Number of users with the field',
  ylab = 'Field'
)
axis(1, at = seq(0, 12000, 2000))
abline(v = nrow(users), col = 2, lty = 2)
text(x = nrow(users), y = 15, labels = paste(nrow(users), 'total users'), col = 2, pos = 2)
text(x = 2500, y = 14, labels = 'Missing data', col = 2)
text(x = 10000, y = 3, labels = 'Complete data', col = 2)
```

### How many views do people have?

```{r n.views}
plot.count(users$n_views, 'views', col = (users$id == 'e8ug-wzay') + 1)
text(x = 0.2, y = 1.2, labels = 'Most users\nhave one view', pos = 4, col = 2)
text(x = 3.5, y = 1.5, labels = 'Data.gov Program\nManagement Office', col = 2)
```

Most users (``sum(users$n_views == 1)`` to be exact) have exactly one view.
Actually, there are probably even more with no views, but I don't have the
data on them.

That one way off to the side is the Data.gov Program Management Office,
with ``users['e8ug-wzay','n_views']``. 

Let's try that again, but I'm going to color the plot by whether the user's role
is "administrator" or "publisher". (Other possibilities are "designer", "editor",
"publisher", "viewer" and a missing value.)

```{r n.views.byrole}
plot.count(users$n_views, 'views', col = 1 + (!is.na(users$roleName) & (users$roleName == 'publisher' | users$roleName == 'administrator')))
```

It looks like publishers and administrators (red) make more views. Big surprize.

### How many tables?

Let's make that same plot, but for the number of tables. (A table is a raw
uploaded dataset, before any view filtering. A table can have many views,
and a view has only one table.)

```{r n.tables}
plot.count(users$n_tables, 'tables', col = 1 + (!is.na(users$roleName) & (users$roleName == 'publisher' | users$roleName == 'administrator')))
text(x = 0.2, y = 1.2, labels = 'Most users\nhave one table', pos = 4, col = 2)
text(x = 3.5, y = 1.5, labels = 'Data.gov Program\nManagement Office', col = 2)
```

That point off to the right is again the Data.gov Program Management Office.o

### How many derived views?
When you upload a tabular data file to Socrata, Socrata creates a table and
a "dataset" view on that table. When you filter a view inside Socrata, Socrata
creates a new view but no new table. Thus, the difference between number of
tables and number of views tells us how many derived views people have made.

```{r n.derived}
plot.count(users$n_views - users$n_tables, 'derived views', col = 1 + ((!is.na(users$roleName) & (users$roleName == 'publisher' | users$roleName == 'administrator'))))
```

It turns out that 65 users have more tables than views. This appears to be mostly
publishers. Maybe this is something about how the import API works that I don't
understand.

```{r publishers}
users[users$n_views < users$n_tables,]
```

I suspect that open data departments upload lots of raw datasets but don't
create very many filters on them; other people do that when they're analyzing
the data. So what happens if we compare the number of derived views that a
user has to the number of tables that she has?

```{r derivedness}
users$n.derived <- users$n_views - users$n_tables
users$prop.derived <- users$n.derived/users$n_views
ggplot(subset(users, n_views >= n_tables)) +
  aes(x = n_tables, y = prop.derived, color = roleName) +
  geom_point() + scale_x_log10('Number of tables')
```

Not that interesting. Let's try a different one.

```{r derivedness.2}
ggplot(subset(users, n_views >= n_tables & id != 'e8ug-wzay')) +
  aes(x = n.derived, y = n_tables, color = roleName) +
  geom_point() + scale_y_log10('Number of tables') + scale_x_log10('Number of derived views')
```

Not that interesting either. Hmm. Let's try this a different way.

### Aside from data publishers and Socrata employees, who uses Socrata a lot?
I have a hunch that the `roleName` field is only populated for people who work
for data publishers.

```{r data.publishers}
subset(users, !is.na(roleName))
users$has.role <- !is.na(users$roleName)
users$has.flag <- !is.na(users$flags)
```

Here are people with tables but no views. (As I mentioned earlier, I didn't
realize that this was possible!) I figure that these people are probably
data publishers.

```{r data.publishers.2}
subset(users, n_tables > 0 & n_views == 0)[c('displayName', 'roleName', 'flags', 'n_tables')]
```

I looked up a few of them with a search engine, and they mostly
[seem](http://www.linkedin.com/in/jkray)
[to](http://www.imaginaryrobots.net/resumes/Jesse_van_Herk_resume.pdf)
[be](http://www.linkedin.com/in/debraagagne)
[government](http://www.whitehouse.gov/champions/technology-and-innovation/waldo-jaquith)
[employees]().


<!-- One example: [Waldo Jaquith](http://waldo.jaquith.org/).
He authored the tables behind
[three](https://explore.data.gov/Contributors/FEC-Committees/fpyy-vyfb?)
[popular](https://explore.data.gov/Federal-Government-Finances-and-Employment/Lobbying-Disclosure-Reports/aqdm-v85k?)
[datasets](https://explore.data.gov/Contributors/FEC-Candidates/wuxv-c8xz?)
on data.explore.gov, but they don't show up in his
[profile](https://explore.data.gov/profile/foo/6q59-uqyb).

    grep -r '"6q59-uqyb"' .|grep explore
-->


```{r socrata.employees}
subset(users, !is.na(flags))['displayName']
```

```{r rolename.and.flag}
subset(users, !is.na(roleName) & !is.na(flags))
```




users$prop.tables <- users$n_tables / users$n_views
# ggplot(users) + aes(x = has.role, y = prop.tables) + geom_violin() + scale_y_sqrt('Proportion of views that are datasets (sort of)') + geom_hline(y = 1)

m <- glm(n_tables ~ has.role * has.flag, data = users, family = 'poisson')
par(mfrow=c(2,2))
print(summary(aov(m)))
par(mfrow=c(1,1))
```

This sort of says that people with roles tend to upload more tables than people
with neither a role nor a flag.

But the variance of the residuals of that model is not consistant, so I wouldn't
put too much faith in it. Let's make a graph instead.

```{r data.publishers}
ggplot(subset(users, id != 'e8ug-wzay')) + aes(x = n_tables, group = paste(has.role, has.flag), fill = paste(has.role, has.flag)) + geom_bar() + scale_x_log10('Number of tables uploaded to the portal')
```

Hmm not that helpful. Let's go back to looking at the individual people.



### profileLastModified
